<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[DL]Winograd快速卷积算法</title>
      <link href="/2019/11/13/dl-winograd-kuai-su-juan-ji-suan-fa/"/>
      <url>/2019/11/13/dl-winograd-kuai-su-juan-ji-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>卷积神经网络是很多任务尤其是计算机视觉任务的基础，但很大程度上，模型需要的大量卷积计算限制了模型的可用性。因此，如何快速的完成卷积操作就至关重要。</p><p>此处的卷积是指图像处理领域的卷积操作，且数据通常为多通道的二维数组，卷积核的长宽相等。</p><p>常用的优化方法包括三个方面：</p><ul><li>硬件：堆数据堆模型再堆硬件是提升性能最常见的手段，本文假设读者都是买不起煤气灶的穷人</li><li>模型复杂度：降低模型复杂度包括降低参数冗余的花式的卷积设计，如ShuffleNet中的分组卷积+通道混合，MobileNet中的Depthwise和Pointwise分解卷积等，以及模型的裁剪、量化和稀疏化。</li><li>框架计算速度：目前主流的深度学习框架在加快计算上，一方面是利用数据SIMD的特性，进行硬件上并行化（SSE、Neon、线程并行），又或者通过一些矢量化手段（如Caffe、MXNet中的im2col）来充分利用软硬件的特点，实现更高的计算速度，另一方面则是像FFT、<a href="https://www.jianshu.com/p/dc67e4a3c841" target="_blank" rel="noopener">Strassen算法</a>以及Winograd算法等在卷积计算原理上不同的方法，从而减少了计算量。</li></ul><p>本文介绍的 Winograd 是存在已久最近被重新发现的方法（The Coppersmith-Winograd Matrix Multiplication Algorithm），在大部分场景中，Winograd 方法都显示和较大的优势，目前TF Lite、Tencent NCNN、Ali MNN 中计算卷积就使用了该方法。详述该方法并进行测试的是CVPR 2016中的一篇文章《Fast Algorithms for Convolutional Neural Networks》，本文主要以该文章来进行方法的介绍和讲解。</p><p>贴两张ARM报告的图来说明一下问题，换言之，我们的问题是需要在<strong>模型（耗时操作主要是小型卷积核如3x3的卷积）和设备确定</strong>的情况下，在<strong>Inference阶段</strong>尽可能快地计算卷积结果。</p><p><img src="fig_arm_1.png" alt></p><p><img src="fig_arm_2.png" alt></p><h2 id="卷积问题定义"><a href="#卷积问题定义" class="headerlink" title="卷积问题定义"></a>卷积问题定义</h2><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>$Image_{H\cdot W\cdot C}$:表示一张多通道（通常为三通道的）图片，使用$I$表示，下标视情况省略，当$C$为1时，表示灰度图，当$W$为1时，表示一维数据</p><p>$Kernel_{R\cdot R}$：表示一个大小为$R$的二维卷积核，使用$K$表示</p><p>$Height/Row,Width/Col,Channel/Depth$：分别表示一张图片的行，列，通道数</p><p>$I_{OH\cdot OW \cdot OC}=Conv(I_{H\cdot W \cdot C},K_R)$：表示使用卷积核$K$对图像$I$进行卷积操作，得到一张新的图像，为了和论文中一致，我们也使用$F(I_{OH\cdot OW \cdot OC},K_R)$来表示上述操作。</p><h3 id="一维卷积"><a href="#一维卷积" class="headerlink" title="一维卷积"></a>一维卷积</h3><ul><li>形式:$I_{OH}=Conv(I_{H},K_R)$或$F(I_{OH},K_R)$</li></ul><p>输出的图像大小取决于卷积核大小、Stride以及Padding策略，在这里我们假设Stride都是1，没有Padding，且只统计乘法运算，则</p><ul><li>计算量：$FLO=OH\cdot R=(H-R+1)\cdot R$</li></ul><h3 id="二维卷积"><a href="#二维卷积" class="headerlink" title="二维卷积"></a>二维卷积</h3><ul><li>形式:$I_{OH\cdot OW \cdot OC}=Conv(I_{H\cdot W\cdot C},K_R)$或$F(I_{OH\cdot OW \cdot OC},K_R)$</li></ul><p>多个通道的二维卷积遵循层内连乘，层间累加的方法，需要的卷积核数量为$C\cdot OC$:</p><ul><li>计算量：$FLO=(OH\cdot OW \cdot OC)\cdot (R\cdot R)\cdot C$</li></ul><p>具体而言，输出图片的每个通道都是通过一组卷积核在所有通道上相乘累加得到的。</p><p><img src="fig_2d_conv.png" alt></p><p>有兴趣的童鞋可以自己算一下需要的加法操作次数，智障作者算了一下应该是$OP=(OH\cdot OW \cdot OC)\cdot ((R\cdot R-1)\cdot C+C-1)=(OH\cdot OW \cdot OC)\cdot (R\cdot R\cdot C-1)$次，和乘法基本相同。</p><p>具体讨论算法的时候我们假设输入输出的通道数都是1，即$FLO=(OH\cdot OW)\cdot (R\cdot R)$。</p><ul><li>形式:$I_{OH\cdot OW}=Conv(I_{H\cdot W},K_R)$或$F(I_{OH\cdot OW},K_R)$</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><blockquote><p>在各种开源框架中，CNN中的conv2d层执行的并不是数学上的卷积计算，而是数学上的互相关计算，具体定义的区别请参考《深度学习》Chap9.1或者<a href="https://www.zhihu.com/question/52237725/answer/545340892" target="_blank" rel="noopener">这个</a>。</p></blockquote><p><img src="fig_conv_dlbook1.png" alt></p><p><img src="fig_conv_dlbook2.png" alt></p><p>在传统的图像处理领域，卷积核的参数是<strong>已知的</strong>（且往往是对称的），而在卷积神经网络中则成为了<strong>待定参数</strong>。实际上，虽然说将卷积核上下翻转并左右翻转（即旋转180度）才是真正的卷积操作，但是也可以认为卷积层做的就是卷积，只是特征矩阵是倒序存储的。又或者说由于卷积核的参数是可变的，这样做不但提高了效率也不影响结果。</p><h2 id="跑题：im2col实现"><a href="#跑题：im2col实现" class="headerlink" title="跑题：im2col实现"></a>跑题：im2col实现</h2><p>im2col是一种非常容易理解的矢量化（Vectorization）手段，基于im2col和GEMM（ General Matrix Multiplication ）的方法可以获得较正常卷积计算较高的加速比，具体而言就是把我们每次进行卷积操作时涉及到的元素展开一个列向量，最终得到一个$I_{(R\cdot R)\cdot (OH\cdot OW)}$的矩阵，卷积核则拆成$K_{1\cdot (R\cdot R)}$的向量。</p><p><img src="fig_im2col.png" alt></p><p>按照同样的方法把卷积核展开，最后卷积操作就可以用一个矩阵乘法来表示，计算完成后，再使用col2im将结果转换为图片。</p><p><img src="fig_im2col_result.png" alt></p><p>这里输入是3个通道，输出是1个，相比写4个for循环，im2col<strong>大大加快了计算速度</strong>（矩阵乘法可并行，数据在内存中的存储连续，Cache命中率提高），但是<strong>没有减少计算量，且内存占用几乎倍增</strong>，另外，生成多通道矩阵依然需要写5个循环（NHWCRR），算是一种用空间来换取时间的做法。关于Caffe中im2col和col2im的实现可以看<a href="https://blog.csdn.net/jiongnima/article/details/69736844" target="_blank" rel="noopener">这里</a>，具体的实现细节其实和我们理解的过程是有较大不同的。</p><p><img src="fig_arm_3.png" alt></p><p>需要强调的一点是，由于我们的硬件设计就是良好支持并行化的，所以<strong>算得少</strong>和<strong>算得快</strong>并不能简单的认为是一回事。</p><p>Caffe原作者贾扬清对其框架中卷积实现的吐槽可以看<a href="https://github.com/Yangqing/caffe/wiki/Convolution-in-Caffe:-a-memo" target="_blank" rel="noopener">这里</a>，摘录一段如下：</p><blockquote><p>In the last few months chatting with people about Caffe, a common comment I got was: “<em>Caffe’s convolution has some memory issues</em>.”</p><p>While this is true in some sense, I am not sure whether it is truly an issue - rather, <strong>it is a graduate-student level design choice when I was writing the Caffe framework in just 2 months’ budget with a looming thesis deadline.</strong> It turns out to have its own pros (faster than any trivial implementation unless you optimize really seriously) and cons (large memory consumption). A more detailed explanation follows, if you are interested.</p><p>……</p><p>Thus, I took a simpler approach: reduce the problem to a simpler one, where others have already optimized it really well. </p></blockquote><p>关于傅里叶变换计算卷积的方法在卷积神经网络中并不是很常用（因为一般还没直接算快），可以参看<a href="https://www.zhihu.com/question/264307400" target="_blank" rel="noopener">这个</a>，Strassen则是在矩阵较大时具有较好的加速效果，具体的方法细节之后再详细说</p><p>（因为作者也没完全看懂╮(￣▽￣)╭）。</p><h2 id="Winograd"><a href="#Winograd" class="headerlink" title="Winograd"></a>Winograd</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在我们的硬件受限的情况下（例如只有单核CPU），如何才能变得更高更快更强呢，由于计算一次乘法所需要的时钟周期要比计算一次加法大很多，对于乘法操作我们能够想象的下界是：输入数据的每个元素至少参与一次乘法。这也是我们力求达到的目标，即乘法次数尽可能的靠近下界。</p><p>形式化的表述，针对一个输出长度为$m$，卷积核大小为$r$的卷积运算，其所需要的最小乘法次数与输入数据的长度相同：</p><p>$$\mu(F(I_m, K_r))=m+r-1=H$$</p><p>每个维度相对独立，因此拓展到二维的情况也是一样的：</p><p>$$\begin{aligned} \mu(F(I_{m \cdot n}, K_{r \cdot s})) =\mu(F(I_{m}, K_{r})) \mu(F(I_{n}, K_{s})) =(m+r-1)(n+s-1) \end{aligned}=H \cdot W$$</p><p>该理论最早由<code>Shmuel Winograd</code>于1980年提出，是本文最重要的理论，没有之一。具体而言，给定一个确定的卷积问题，我们可以找到一种变换，来接近（甚至到达）乘法次数的理论下界。根据该理论，在卷积核较小的情况下，我们可以获得相对普通卷积计算而言较大的加速比。</p><h4 id="F-I-2-K-3-与-F-I-2-cdot-2-K-3-cdot-3"><a href="#F-I-2-K-3-与-F-I-2-cdot-2-K-3-cdot-3" class="headerlink" title="$F(I_2,K_3)$与$F(I_{2\cdot 2},K_{3 \cdot 3})$"></a>$F(I_2,K_3)$与$F(I_{2\cdot 2},K_{3 \cdot 3})$</h4><p>举个例子，$F(I_2,K_3)$表示输入信号$d=\left[ \begin{array}{llll}{d_{0}} &amp; {d_{1}} &amp; {d_{2}} &amp; {d_{3}}\end{array}\right]^{T}$，卷积核$g=\left[ \begin{array}{lll}{g_{0}} &amp; {g_{1}} &amp; {g_{2}}\end{array}\right]^{T}$的一维卷积操作。那么问题就可以表示为如下的形式：</p><p>$$F(I_2,K_3) = \left[ \begin{array}{lll}{d_{0}} &amp; {d_{1}} &amp; {d_{2}} \\ {d_{1}} &amp; {d_{2}} &amp; {d_{3}}\end{array}\right] \left[ \begin{array}{l}{g_{0}} \\ {g_{1}} \\ {g_{2}}\end{array}\right]=\left[ \begin{array}{c}{r_0} \\ {r_1}\end{array}\right]$$</p><p> 如果是一般的矩阵乘法，则需要<strong>6次乘法和4次加法</strong>，如下： </p><p>$$\begin{array}{l}{r_{0}=\left(d_{0} \cdot g_{0}\right)+\left(d_{1} \cdot g_{1}\right)+\left(d_{2} \cdot g_{2}\right)} \\ {r_{1}=\left(d_{1} \cdot g_{0}\right)+\left(d_{2} \cdot g_{1}\right)+\left(d_{3} \cdot g_{2}\right)}\end{array}$$</p><p>但是，卷积运算中输入信号转换成的矩阵不是任意矩阵，其中<strong>有规律地分布着大量的重复元素</strong>，因此卷积转换成的矩阵乘法比一般矩阵乘法的问题域更小，这就让优化存在了可能。</p><p>Winograd的具体做法是， </p><p>$$F(I_2,K_3) = \left[ \begin{array}{lll}{d_{0}} &amp; {d_{1}} &amp; {d_{2}} \\ {d_{1}} &amp; {d_{2}} &amp; {d_{3}}\end{array}\right] \left[ \begin{array}{l}{g_{0}} \\ {g_{1}} \\ {g_{2}}\end{array}\right]=\left[ \begin{array}{c}{m_{1}+m_{2}+m_{3}} \\ {m_{2}-m_{3}-m_{4}}\end{array}\right]$$</p><p>其中，</p><p>$$\begin{array}{ll}{m_{1}=\left(d_{0}-d_{2}\right) g_{0}} &amp; {m_{2}=\left(d_{1}+d_{2}\right) \frac{g_{0}+g_{1}+g_{2}}{2}} \\ {m_{4}=\left(d_{1}-d_{3}\right) g_{2}} &amp; {m_{3}=\left(d_{2}-d_{1}\right) \frac{g_{0}-g_{1}+g_{2}}{2}}\end{array}$$</p><p><strong>在神经网络的推理阶段，卷积核$g$上的元素是固定的</strong>，共3次加法与2次乘法，因此$g$相关的运算可以提前算好，预测阶段只需计算一次，可以忽略，所以一共所需的运算次数<strong>4次乘法和8次加法/减法</strong>，和下界一致。 速度提升比例为<strong>1.5倍</strong>。当然所需要的存储空间也相应的增加，由原来的$r$增加为$H$，即从卷积核大小变成了输入数据的宽度。</p><p>可是这怎么就能减少计算量呢，会不会得到的结果不一样？有兴趣的童鞋可以自行把所有符号代入化简，针对这个例子，得到的结果是<strong>完全相同</strong>的！当然在具体计算的时候可能会存在浮点精度误差。因此在这个例子里面完全就是仅仅使用不同的数学表示就达到了减少计算量的目的，真是太巧妙了。</p><h4 id="一维卷积形式化表述"><a href="#一维卷积形式化表述" class="headerlink" title="一维卷积形式化表述"></a>一维卷积形式化表述</h4><p>上述例子可以用通用矩阵乘法（GEMM）和元素级乘法（EWMM）的混合矩阵变换来形式化表述。</p><p>一维卷积的形式化表述如下：</p><p>$$Y=A^{T}\left[(G g) \odot\left(B^{T} d\right)\right]$$</p><p>详细解释如下：</p><ul><li>$g$：卷积核 ，维度$r\cdot 1$</li><li>$d$：输入信号，维度$H\cdot 1$</li><li>$G$：Filter transform矩阵，用于将卷积核变换到另一个空间，维度$(m+r-1)\cdot r=H \cdot r$</li><li>$B^T$：Input transform矩阵，用于将输入数据变换到另一个空间，维度$(m+r-1)\cdot (m+r-1)=H \cdot H$</li><li>$A^T$：Output transform矩阵，用于将数据转换回输出空间，维度$m\cdot (m+r-1)=m*H$</li><li>$Y$：卷积结果，维度$m\cdot 1$</li></ul><p>其中，$\odot$表示对应位置相乘，暗示此处两个矩阵的维度是一致的，上面的例子里面具体的参数如下，<br>$$<br>B^{T}=\left[ \begin{array}{cccc}{1} &amp; {0} &amp; {-1} &amp; {0} \\ {0} &amp; {1} &amp; {1} &amp; {0} \\ {0} &amp; {-1} &amp; {1} &amp; {0} \\ {0} &amp; {1} &amp; {0} &amp; {-1}\end{array}\right]<br>$$</p><p>$$<br>G=\left[ \begin{array}{ccc}{1} &amp; {0} &amp; {0} \\ {\frac{1}{2}} &amp; {\frac{1}{2}} &amp; {\frac{1}{2}} \\ {\frac{1}{2}} &amp; {-\frac{1}{2}} &amp; {\frac{1}{2}} \\ {0} &amp; {0} &amp; {1}\end{array}\right]<br>$$</p><p>$$<br>A^{T}=\left[ \begin{array}{llll}{1} &amp; {1} &amp; {1} &amp; {0} \\ {0} &amp; {1} &amp; {-1} &amp; {-1}\end{array}\right]<br>$$</p><p>$$<br>g=\left[ \begin{array}{lll}{g_{0}} &amp; {g_{1}} &amp; {g_{2}}\end{array}\right]^{T},d=\left[ \begin{array}{llll}{d_{0}} &amp; {d_{1}} &amp; {d_{2}} &amp; {d_{3}}\end{array}\right]^{T}<br>$$</p><p>整个计算过程在逻辑上可以分为4步：</p><ul><li>Input transform</li><li>Filter transform</li><li>Hadamard product（ 哈达玛积 ）</li><li>Output transform</li></ul><p>此处，$A^{T}$即$m$前面的系数，$B^{T}$即数据$d$前面的系数，$G$即卷积核$g$前面的系数，由于卷积核相关参数是提前计算好的，虽然我们将卷积的过程表述成了矩阵乘法的形式，<strong>但是此处只有$\odot$包含了乘法</strong>，其他的系数全是$\pm 1$，因此只有加减法。之后会提到具体如何实现，有兴趣的同学可以先自己思考一下下。</p><h4 id="二维卷积形式化表述"><a href="#二维卷积形式化表述" class="headerlink" title="二维卷积形式化表述"></a>二维卷积形式化表述</h4><p>文中关于一维卷积向二维卷积的扩展只有寥寥数语：</p><blockquote><p>A minimal 1D algorithm $F(m, r)$ is nested with itself to obtain a minimal 2D algorithm.</p><p>The nesting technique can be generalized for non-square filters and outputs,$F(m × n, r × s)$,<br>by nesting an algorithm for $F(m, r)$ with an algorithm for $F(n, s)$.</p></blockquote><p>文中给出的二维卷积形式化表述如下：<br>$$<br>Y=A^{T}\left[\left[G g G^{T}\right] \odot\left[B^{T} d B\right]\right] A<br>$$<br>详细解释如下：</p><ul><li>$g$：卷积核 ，维度$r\cdot r$</li><li>$d$：输入信号，维度$H\cdot H$</li><li>$G$：Filter transform矩阵，用于将卷积核变换到另一个空间，维度$(m+r-1)\cdot r=H \cdot r$</li><li>$B^T$：Input transform矩阵，用于将输入数据变换到另一个空间，维度$(m+r-1)\cdot (m+r-1)=H \cdot H$</li><li>$A^T$：Output transform矩阵，用于将数据转换回输出空间，维度$m\cdot (m+r-1)=m*H$</li><li>$Y$：卷积结果，维度$m\cdot m$</li></ul><p>对于$F(I_{2\cdot 2},K_{3 \cdot 3})$，其中所有矩阵中的参数，包括$G$，$B^T$，$A^T$都是和$F(I_2,K_3)$一样的。</p><p>依然只有$\odot$包含了乘法，乘法的次数为16次，相比于标准卷积的次数$36=2\times 2 \times 3 \times 3$，速度提升比例为<strong>2.25倍</strong>。其中Input transform包括$32=4\times 4 \times 2$次加法，Filter transform包括28次浮点数操作（预先计算），Output transform（Inverse transform）包括$24=2\times 2 \times 3 \times 2$次加法。</p><p>等等，怎么就<code>nested with itself</code>了，参数还是一样的？</p><p>那么问题来了：</p><ul><li>二维卷积的形式化表述是否正确，如何证明</li><li>通常输入的图像尺寸都较大，如何使用Winograd对其进行卷积计算，难道要实现$F(I_{448\cdot 448}, K_{3 \cdot 3})$吗，三维的卷积（卷积神经网络中的实际情况）该如何实现</li><li>上面形式化表示中所使用的矩阵参数该如何获得</li><li>形式化表示中的矩阵乘法看起来似乎比常规卷积做了更多的乘法操作，真正的算法实现是如何转换成加法的</li></ul><h4 id="二维卷积形式化推导"><a href="#二维卷积形式化推导" class="headerlink" title="二维卷积形式化推导"></a>二维卷积形式化推导</h4><p>我们先来解决第一个问题，要完成形式化的推导，我们需要先理解文章中的<code>nested with itself</code>到底是什么意思。下列图片来自ARM在Embedded Vision Summit 2018上的Slides，里面的符号表示会略有不同（ 用$k$来表示输入，$w$表示权重，$r$表示输出 ）。</p><p><img src="fig_arm_winograd_nest_0.png" alt></p><p>我们以$F(I_{2\cdot 2},K_{3 \cdot 3})$为例，输入图片是$4\times 4$的，输出是$2\times 2$的，卷积核如下：<br>$$<br>W = \left[\begin{array}{lll}{w_{0}} &amp; {w_{1}} &amp; {w_{2}} \\ {w_{3}} &amp; {w_{4}} &amp; {w_{5}} \\ {w_{6}} &amp; {w_{7}} &amp; {w_{8}}\end{array}\right]<br>$$<br>根据我们之前对标准卷积的运算次数推导，$FLO=(OH\cdot OW \cdot OC)\cdot (R\cdot R)\cdot C=36$，$OP=(OH\cdot OW \cdot OC)\cdot (R\cdot R\cdot C-1)=32$，即需要<strong>36次乘法和32次加法</strong>。</p><p>现在我们按照<strong>im2row</strong>的形式展开卷积流程，可以得到如下的矩阵运算：</p><p><img src="fig_arm_winograd_nest_1.png" alt></p><p>仔细观察可以发现，左侧矩阵中的部分元素是重复出现的，我们按照相同的颜色对其进行标记，并以此来进行矩阵和向量的分块操作：</p><p><img src="fig_arm_winograd_nest_2.png" alt>使用更加简洁的表述，我们得到了如下所示的分块运算，现在问题的表述和$F(I_2,K_3)$完全一致了，不同的是我们的每一对元素操作都是$F(I_2,K_3)$，这就是$F(I_{2\cdot 2},K_{3 \cdot 3})$的<strong>堆叠实现</strong>：</p><p><img src="fig_arm_winograd_nest_3.png" alt></p><p>形式化的表述如下：<br>$$<br>\begin{aligned} \left[\begin{array}{lll}{K_0} &amp; {K_1} &amp; {K_2} \\ {K_1} &amp; {K_2} &amp; {K_3} \end{array}\right] \left[\begin{array}{l}{W_0} \\ {W_1} \\ {W_2} \end{array}\right] &amp;= \left[\begin{array}{l}{R_0} \\ {R_1} \end{array}\right] = \left[\begin{array}{l}{K_0W_0+K_1W_1+K_2W_2} \\ {K_1W_0+K_2W_1+K_3W_2} \end{array}\right] \\ \\ &amp;= \left[\begin{array}{l}{F_{(2,3)}(D_0,W_0)+F_{(2,3)}(D_1,W_1)+F_{(2,3)}(D_2,W_2)} \\ {F_{(2,3)}(D_1,W_0)+F_{(2,3)}(D_2,W_1)+F_{(2,3)}(D_3,W_2)} \end{array}\right] \end{aligned}<br>$$<br>其中，$D_i$是$K_i$对应的输入序列，也即卷积输入的第$i$行:<br>$$<br>D = d^T=\left[\begin{array}{llll} {k_0} &amp; {k_4} &amp; {k_8} &amp; {k_{12}} \\ {k_1} &amp; {k_5} &amp; {k_9} &amp; {k_{13}} \\ {k_2} &amp; {k_6} &amp; {k_{10}} &amp; {k_{14}} \\ {k_3} &amp; {k_7} &amp; {k_{11}} &amp; {k_{15}} \end{array}\right] = \left[\begin{array}{l} D_0 &amp; D_1 &amp; D_2 &amp; D_3 \end{array}\right]<br>$$<br>我们一共使用6个$F(I_2,K_3)$来计算$F(I_{2\cdot 2},K_{3 \cdot 3})$，并额外增加了8次加法，之前提到$F(I_2,K_3)$一共所需的运算次数为4次乘法和8次加法，所以计算时期共计<strong>24次乘法与48​次加法</strong>， 速度提升比例为<strong>1.5倍</strong>。在卷积核预处理阶段，需要进行8次乘法和12次加法。</p><p>有兴趣的童鞋可以思考一下为什么是48次加法，因为数据有部分重复，数据变换（Input transform）只需要做4次，此处共计16次加法，而Output transform则是6次，共计24次加法，另外还有8次额外的加法（虽然只有4个加号却是8次）。</p><p>之前曾经提到，最小的乘法次数应该和输入的数据规模相等，因此这还不是最高的加速比（最高应该是<strong>$2.25=36\div 16$倍</strong>），还记得我们之前的一维卷积形式化表述吗，下面的图片中的所有表述和$F(I_2,K_3)$是完全一致的，但是每个元素都用矩阵和向量替换了：</p><p><img src="fig_arm_winograd_nest_4.png" alt></p><p>按照这种方式，我们可以得到$F(I_{2\cdot 2},K_{3 \cdot 3})$的<strong>嵌套实现</strong>，形式化的表述如下：<br>$$<br>\begin{aligned} \left[ \begin{array}{c}{R_0} \\ {R_1}\end{array}\right] &amp;= \left[ \begin{array}{c}{K_0 W_0 + K_1 W_1 + K_2 W_2} \\ {K_1 W_0 + K_2 W_1 + K_3 W_2} \end{array} \right] \\ \\ &amp;= \left[\begin{array}{l}{F_{(2,3)}(D_0,W_0)+F_{(2,3)}(D_1,W_1)+F_{(2,3)}(D_2,W_2)} \\ {F_{(2,3)}(D_1,W_0)+F_{(2,3)}(D_2,W_1)+F_{(2,3)}(D_3,W_2)} \end{array}\right] \\ &amp;= \left[ \begin{array}{c} {A^{T}\left[(G W_0) \odot\left(B^{T} D_0 \right)\right] + A^{T}\left[(G W_1) \odot\left(B^{T} D_1 \right)\right] + A^{T}\left[(G W_2) \odot\left(B^{T} D_2 \right)\right]} \\ {A^{T}\left[(G W_0) \odot\left(B^{T} D_1 \right)\right] + A^{T}\left[(G W_1) \odot\left(B^{T} D_2 \right)\right] + A^{T}\left[(G W_2) \odot\left(B^{T} D_3 \right)\right]} \end{array} \right] \\ \\ &amp;=A^{T}\left[\left[G [W_0 \ W_1 \ W_2 ] G^{T}\right] \odot\left[B^{T} [D_0 \ D_1 \ D_2 \ D_3] B\right]\right]A \\ \\ &amp;=A^{T}\left[\left[G w G^{T}\right] \odot\left[B^{T} d B\right]\right] A \\ \\ &amp;\textit{(…w =&gt; g…)} \\ \\ &amp;=A^{T}\left[\left[G g G^{T}\right] \odot\left[B^{T} d B\right]\right] A \end{aligned}<br>$$<br>中间的一步变化很关键，$\left[(G W_i) \odot\left(B^{T} D_j \right)\right]$是一个长度为4的列向量,$A^{T}\left[(G W_i) \odot\left(B^{T} D_j \right)\right]$则是一个长度为2的列向量，$A^{T}\left[(G W_0) \odot\left(B^{T} D_0 \right)+ (G W_1) \odot\left(B^{T} D_1 \right) + (G W_2) \odot\left(B^{T} D_2 \right)\right]$ 方括号内对应位置相乘再相加，相当于在每组相点乘结果构成的行向量上做卷积。最后的结果是一个长度为2的列向量。</p><p>实际上两种表述的维度并不相同，前者的维度是$I_{4\cdot 1}$，后者是$I_{2\cdot 2}$。</p><p>此处的推导过于复杂，作者并不会，有兴趣的童鞋可以去试一下这段代码，其作用是代入$F(I_{2\cdot 2},K_{3 \cdot 3})$的参数和符号，进行两种表达的展开，最后证明相等:</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sympy <span class="token keyword">import</span> Symbol<span class="token punctuation">,</span> Matrix<span class="token punctuation">,</span>pprint<span class="token punctuation">,</span>simplify<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npBT <span class="token operator">=</span> Matrix<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>G <span class="token operator">=</span> Matrix<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>G<span class="token operator">=</span>G<span class="token operator">/</span><span class="token number">2</span>AT <span class="token operator">=</span> Matrix<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>g <span class="token operator">=</span> Matrix<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Symbol<span class="token punctuation">(</span>f<span class="token string">'g{i}'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d <span class="token operator">=</span> Matrix<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Symbol<span class="token punctuation">(</span>f<span class="token string">'d{i}'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>m <span class="token operator">=</span> Matrix<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Symbol<span class="token punctuation">(</span>f<span class="token string">'m{i}'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'GgGT:'</span><span class="token punctuation">)</span>GgGT<span class="token operator">=</span>G<span class="token operator">*</span>g<span class="token operator">*</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>T<span class="token punctuation">)</span>pprint<span class="token punctuation">(</span>GgGT<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'BTdB'</span><span class="token punctuation">)</span>BTdB<span class="token operator">=</span>BT<span class="token operator">*</span>d<span class="token operator">*</span><span class="token punctuation">(</span>BT<span class="token punctuation">.</span>T<span class="token punctuation">)</span>pprint<span class="token punctuation">(</span>BTdB<span class="token punctuation">)</span>RET1<span class="token operator">=</span><span class="token punctuation">(</span>AT<span class="token operator">*</span>np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>GgGT<span class="token punctuation">,</span>BTdB<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>AT<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'AT * [GgGT em BTdB] * A ,shape={shape},first:'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>shape<span class="token operator">=</span>RET1<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span>pprint<span class="token punctuation">(</span>simplify<span class="token punctuation">(</span>RET1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>R0<span class="token operator">=</span><span class="token punctuation">(</span>AT<span class="token operator">*</span>np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>G<span class="token operator">*</span>g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">,</span>BT<span class="token operator">*</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token operator">+</span>AT<span class="token operator">*</span>np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>G<span class="token operator">*</span>g<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">,</span>BT<span class="token operator">*</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token operator">+</span>AT<span class="token operator">*</span>np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>G<span class="token operator">*</span>g<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">,</span>BT<span class="token operator">*</span>d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>R1<span class="token operator">=</span><span class="token punctuation">(</span>AT<span class="token operator">*</span>np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>G<span class="token operator">*</span>g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">,</span>BT<span class="token operator">*</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token operator">+</span>AT<span class="token operator">*</span>np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>G<span class="token operator">*</span>g<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">,</span>BT<span class="token operator">*</span>d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token operator">+</span>AT<span class="token operator">*</span>np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>G<span class="token operator">*</span>g<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">,</span>BT<span class="token operator">*</span>d<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'R0 ,shape={shape},first:'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>shape<span class="token operator">=</span>R0<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span>pprint<span class="token punctuation">(</span>simplify<span class="token punctuation">(</span>R0<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Diff of first:'</span><span class="token punctuation">)</span>pprint<span class="token punctuation">(</span>simplify<span class="token punctuation">(</span>RET1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>R0<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Diff of all:'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>simplify<span class="token punctuation">(</span>RET1<span class="token operator">-</span>np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">(</span>R0<span class="token punctuation">.</span>T<span class="token punctuation">,</span>R1<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过这样一番推导（虽然最关键的一步跳过了，嘻嘻嘻）我们就可以得到$F(I_{2\cdot 2},K_{3 \cdot 3})$的<strong>嵌套实现</strong>，<br>$$<br>F(I_{2\cdot 2},K_{3 \cdot 3})= A^{T} \left[ U \odot V \right] A<br>$$</p><p>其中，$U = G g G^{T},V = B^{T} d B$，一共需要 <strong>16次乘法和56次加法</strong>（$V = B^{T} d B$过程32次加法、$M=U \odot V$过程16次乘法、$Y=A^TMA$过程24次加法）。和一维卷积类似的，所需要的存储空间也相应的增加，由原来的$r\cdot r$增加为$H\cdot W$，即从卷积核大小变成了输入数据的宽度。</p><h4 id="扩展到-F-I-4-cdot-4-K-3-cdot-3"><a href="#扩展到-F-I-4-cdot-4-K-3-cdot-3" class="headerlink" title="扩展到$F(I_{4\cdot 4},K_{3 \cdot 3})$"></a>扩展到$F(I_{4\cdot 4},K_{3 \cdot 3})$</h4><p>算法本身可以被扩展到更大的输入输出尺寸，从而可能得到更高的加速比，但是参数数量和加法操作次数也相应的大大增加。<br>要计算$F(I_{4\cdot 4},K_{3 \cdot 3})$，我们的输入是$6\times 6$的图片，常规卷积的操作需要计算$144=4\times 4\times 3\times3$次乘法，但是使用Winograd只需要$36=6\times 6$次乘法，速度提升比例为<strong>4倍</strong>。具体参数如下：<br>$$<br>B^{T}=\left[\begin{array}{rrrrrr}{4} &amp; {0} &amp; {-5} &amp; {0} &amp; {1} &amp; {0} \\ {0} &amp; {-4} &amp; {-4} &amp; {1} &amp; {1} &amp; {0} \\ {0} &amp; {4} &amp; {-4} &amp; {-1} &amp; {1} &amp; {0} \\ {0} &amp; {-2} &amp; {-1} &amp; {2} &amp; {1} &amp; {0} \\ {0} &amp; {2} &amp; {-1} &amp; {-2} &amp; {1} &amp; {0} \\ {0} &amp; {4} &amp; {0} &amp; {-5} &amp; {0} &amp; {1}\end{array}\right]<br>$$<br>$$<br>G=\left[\begin{array}{rrr}{\frac{1}{4}} &amp; {0} &amp; {0} \\ {-\frac{1}{6}} &amp; {-\frac{1}{6}} &amp; {-\frac{1}{6}} \\ {-\frac{1}{6}} &amp; {\frac{1}{6}} &amp; {-\frac{1}{6}} \\ {\frac{1}{24}} &amp; {\frac{1}{12}} &amp; {\frac{1}{6}} \\ {\frac{1}{24}} &amp; {-\frac{1}{12}} &amp; {\frac{1}{6}} \\ {0} &amp; {0} &amp; {1}\end{array}\right]<br>$$<br>$$<br>A^{T}=\left[\begin{array}{rrrrrr}{1} &amp; {1} &amp; {1} &amp; {1} &amp; {1} &amp; {0} \\ {0} &amp; {1} &amp; {-1} &amp; {2} &amp; {-2} &amp; {0} \\ {0} &amp; {1} &amp; {1} &amp; {4} &amp; {4} &amp; {0} \\ {0} &amp; {1} &amp; {-1} &amp; {8} &amp; {-8} &amp; {1}\end{array}\right]<br>$$</p><blockquote><p>The number of additions and constant multiplications required by the minimal Winograd transforms increases quadratically with the tile size. Thus for large tiles, the complexity of the transforms will overwhelm any savings in the number of multiplications.</p><p>The magnitude of the transform matrix elements also increases with increasing tile size. This effectively reduces the numeric accuracy of the computation, so that for large tiles, the transforms cannot be computed accurately.</p></blockquote><p>但是浮点操作次数也大大增加了，其中Input transform包括$144=12\times (6+6)$次浮点数操作（注意此时的系数已经不全是1了，因此也会包括乘法），Filter transform包括72次浮点数操作（预先计算），Output transform（Inverse transform）包括$100=10\times (6+4)$次浮点数操作。</p><p>此外，转换矩阵的规模增大导致了计算精度误差增加，不过作者认为卷积神经网络对精度的要求其实比较低，因此在附录中讨论了$F(I_{6\cdot 6},K_{3 \cdot 3})$的可能性，其参数如下：<br>$$<br>B^{T}=\left[\begin{array}{rrrrrrrr}   {1} &amp; {0} &amp; {-21/4} &amp; {0} &amp; {21/4} &amp; {0} &amp; {-1} &amp; {0} \\   {0} &amp; {1} &amp; {1} &amp; {-17/4} &amp; {-17/4} &amp; {1} &amp; {1} &amp; {0} \\   {0} &amp; {-1} &amp; {1} &amp; {17/4} &amp; {-17/4} &amp; {-1} &amp; {1} &amp; {0} \\   {0} &amp; {1/2} &amp; {1/4} &amp; {-5/2} &amp; {-5/4} &amp; {2} &amp; {1} &amp; {0} \\   {0} &amp; {-1/2} &amp; {1/4} &amp; {5/2} &amp; {-5/4} &amp; {-2} &amp; {1} &amp; {0} \\   {0} &amp; {2} &amp; {4} &amp; {-5/2} &amp; {-5} &amp; {1/2} &amp; {1} &amp; {0} \\   {0} &amp; {-2} &amp; {4} &amp; {5/2} &amp; {-5} &amp; {-1/2} &amp; {1} &amp; {0} \\   {0} &amp; {-1} &amp; {0} &amp; {21/4} &amp; {0} &amp; {-21/4} &amp; {0} &amp; {1}   \end{array}\right],   \\   G=\left[\begin{array}{rrr}   {1} &amp; {0} &amp; {0} \\   {-2/9} &amp; {-2/9} &amp; {-2/9} \\   {-2/9} &amp; {2/9} &amp; {-2/9} \\   {1/90} &amp; {1/45} &amp; {2/45} \\   {1/90} &amp; {-1/45} &amp; {2/45} \\   {32/45} &amp; {16/45} &amp; {8/45} \\   {32/45} &amp; {-16/45} &amp; {8/45} \\   {0} &amp; {0} &amp; {1}   \end{array}\right],   \\   A^{T}=\left[\begin{array}{rrrrrrrr}   {1} &amp; {1} &amp; {1} &amp; {1} &amp; {1} &amp; {1} &amp; {1} &amp; {0} \\   {0} &amp; {1} &amp; {-1} &amp; {2} &amp; {-2} &amp; {1/2} &amp; {-1/2} &amp; {0} \\   {0} &amp; {1} &amp; {1} &amp; {4} &amp; {4} &amp; {1/4} &amp; {1/4} &amp; {0} \\   {0} &amp; {1} &amp; {-1} &amp; {8} &amp; {-8} &amp; {1/8} &amp; {-1/8} &amp; {0} \\   {0} &amp; {1} &amp; {1} &amp; {16} &amp; {16} &amp; {1/16} &amp; {1/16} &amp; {0} \\   {0} &amp; {1} &amp; {-1} &amp; {32} &amp; {-32} &amp; {1/32} &amp; {-1/32} &amp; {1} \\   \end{array}\right]<br>$$<br>相比直接卷积324次的乘法操作，$F(I_{6\cdot 6},K_{3 \cdot 3})$只需要64次，加速比达到<strong>5.06倍</strong>（然而并没有）。我们目前讨论的都是$3\times 3$的卷积，只是<code>tile</code>大小不同。</p><h3 id="基于Winograd的卷积计算算法流程"><a href="#基于Winograd的卷积计算算法流程" class="headerlink" title="基于Winograd的卷积计算算法流程"></a>基于Winograd的卷积计算算法流程</h3><p>第二个问题，其实我们并不会真的去实现$F(I_{448\cdot 448}, K_{3 \cdot 3})$，而是将图片划分成多个相同大小部分重叠的<code>tile</code>，在此基础上使用如$F(I_{2\cdot 2},K_{3 \cdot 3})$的方式来计算，最后合并统计结果。对于三维卷积，实际上是和标准卷积一样，逐层做二维卷积，再每层对应位置结果相加。但除此之外，针对多个卷积核还有更加巧妙的做法。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p><code>tile</code>在此处代表一个图像块，具体划分方式如下：</p><ul><li>每个<code>tile</code>的大小为$H\times H=(m+r-1)(m+r-1)$</li><li>每个<code>tile</code>互相重叠的长度为$r-1$</li><li>每个通道可以划分成$P=\lceil H / m\rceil\lceil W / m\rceil $个<code>tile</code>，注意此处的$H$表示的是通道的大小，和之前的不同，之后的算法表述也会出现类似的情况</li></ul><p>之所以有部分重叠，是因为我们的卷积结果其实小于原图的大小，而每一边减小的大小就是$r-1$。</p><p>下图展示了标准卷积和Winograd $F(I_{2\cdot 2},K_{3 \cdot 3})$的区别,标准的卷积过程：</p><p><img src="fig_standard_conv.gif" alt></p><p>Winograd $F(I_{2\cdot 2},K_{3 \cdot 3})$:</p><p><img src="fig_winograd_conv.gif" alt></p><p>之前提到，计算公式如下所示：<br>$$<br>F(I_{m\cdot m},K_{r \cdot r})= A^{T} \left[ U \odot V \right] A \\U = G g G^{T}\\V = B^{T} d B<br>$$</p><ol><li>Winograd的输入为固定大小，因此需要先对图像做Padding，每个<code>tile</code>的步长即为非重叠的长度$m$</li><li>$U$已经提前计算好，$V$每个<code>tile</code>计算一次</li><li>最后输出的图像部分是不需要的，需要做裁剪，裁剪宽度和Padding宽度相同</li></ol><blockquote><p>前述只讨论了一些比较简单的情况，事实上在CNN中，由于输入的特征图只需要变换一次，而却会被多个滤波器复用，所以输入变换过程的额外开销会被平摊——卷积的滤波器（也即输出通道）越多，那么输入变换产生的额外开销的影响就越小。 </p></blockquote><h4 id="多通道多卷积核"><a href="#多通道多卷积核" class="headerlink" title="多通道多卷积核"></a>多通道多卷积核</h4><p>在图片$i$，通道$c$，卷积核$k$上做标准卷积可以用如下的形式表示：<br>$$<br>{Y_{i, k, x, y}=\sum_{c=1}^{C} \sum_{v=1}^{R} \sum_{u=1}^{S} D_{i, c, x+u, y+v} G_{k, c, u, v}}<br>$$</p><p>我们可以使用星号来表示2D互相关的过程，<br>$$<br>Y_{i, k}=\sum_{c=1}^{C} D_{i, c} * G_{k, c}<br>$$</p><p>我们使用$(\tilde{x}, \tilde{y})$来表示<code>tile</code>的坐标，则Winograd卷积可以被表示成如下形式：<br>$$<br>{\qquad \begin{aligned} Y_{i, k, \widetilde{x}, \widetilde{y}} &amp;=\sum_{c=1}^{C} D_{i, c, \widetilde{x}, \widetilde{y}} * G_{k, c} \\ &amp;=\sum_{c=1}^{C} A^{T}\left[U_{k, c} \odot V_{c, i, \widetilde{x}, \bar{y}}\right] A \\ &amp;=A^{T}\left[\sum_{c=1}^{C} U_{k, c} \odot V_{c, i, \widetilde{x}, \widetilde{y}}\right] A \end{aligned}}<br>$$<br>因此，我们可以在变换的空间就对通道的那个维度求和，不需要等到输出变换（Inverse Transform）。<br>$$<br>M_{k, i, \widetilde{x}, \widetilde{y}}=\sum_{c=1}^{C} U_{k, c} \odot V_{c, i, \widetilde{x}, \widetilde{y}}<br>$$<br>按照图像/<code>tile</code>坐标$(i,\tilde{x}, \tilde{y})$的方式将数据全部展开至一个维度，我们可以将之前的遍历操作转换得到如下的矩阵乘法表示，其中$(\xi, \nu)$遍历的是每个<code>tile</code>大小的区域，表示一个逐点相乘的操作：<br>$$<br>M_{k, b}^{(\xi, \nu)}=\sum_{c=1}^{C} U_{k, c}^{(\xi, \nu)} V_{c, b}^{(\xi, \nu)}<br>$$<br>该表述实际上就是矩阵乘法，在下文的图中可以跟清晰的看出来，现在计算过程的表述如下，整个过程一共要重复<code>tile</code>大小的次数：<br>$$<br>M^{(\xi, \nu)}=U^{(\xi, \nu)} V^{(\xi, \nu)}<br>$$<br>综上，文章中描述的算法流程如下所示：</p><p><img src="fig_algorithm_1.png" alt></p><p>在文章《 <a href="https://www.researchgate.net/publication/328091476_Sparse_Winograd_Convolutional_neural_networks_on_small-scale_systolic_arrays/figures" target="_blank" rel="noopener">Sparse Winograd Convolutional neural networks on small-scale systolic arrays</a> 》中描述了多通道多卷积核的Winograd计算流程，和单通道不同的是，此处我们依然是使用GEMM来计算整个卷积过程，因此针对im2col中GEMM部分的优化在此处依然适用。</p><p>算法整体依然分为四步：</p><ol><li>Filter Transform</li><li>Input transform</li><li>Hadamard product $-&gt;$ Batched-GEMM（批量矩阵乘法）</li><li>Output transform</li></ol><p><img src="fig_winograd_overview.ppm" alt></p><p>Winograd中和矩阵乘法不同的地方主要是有一个元素级乘法（EWMM）的操作，而在这种使用GEMM表示的计算流程中，巧妙的将多通道和多卷积核使用矩阵表示，参与GEMM操作的矩阵尺寸分别为$\lceil H / m\rceil\lceil W / m\rceil \times C$和$C \times K$，一共做了$(m+r-1)^2=H\times W$个矩阵乘法操作（此处为Winograd输入大小，和图像大小不同），通道的那个维度在矩阵乘法中就被消掉了。而元素级乘法（EWMM）的操作实际上就在$(m+r-1)^2=H\times W$那么多个矩阵乘法操作中进行。无论是单个GEMM操作内部，还是多个GEMM操作都可以使用GEMM的并行技巧。</p><h3 id="参数推导（劝退节）"><a href="#参数推导（劝退节）" class="headerlink" title="参数推导（劝退节）"></a>参数推导（劝退节）</h3><h4 id="欧几里得定理（辗转相除法）"><a href="#欧几里得定理（辗转相除法）" class="headerlink" title="欧几里得定理（辗转相除法）"></a>欧几里得定理（辗转相除法）</h4><h4 id="贝祖定理"><a href="#贝祖定理" class="headerlink" title="贝祖定理"></a>贝祖定理</h4><h4 id="扩展欧几里得定理"><a href="#扩展欧几里得定理" class="headerlink" title="扩展欧几里得定理"></a>扩展欧几里得定理</h4><h4 id="中国剩余定理CRT"><a href="#中国剩余定理CRT" class="headerlink" title="中国剩余定理CRT"></a>中国剩余定理CRT</h4><h4 id="拉格朗日插值法"><a href="#拉格朗日插值法" class="headerlink" title="拉格朗日插值法"></a>拉格朗日插值法</h4><h4 id="Cook-Toom-algorithm"><a href="#Cook-Toom-algorithm" class="headerlink" title="Cook-Toom algorithm"></a>Cook-Toom algorithm</h4><h4 id="Winograd-Algorithm"><a href="#Winograd-Algorithm" class="headerlink" title="Winograd Algorithm"></a>Winograd Algorithm</h4><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="计算优化"><a href="#计算优化" class="headerlink" title="计算优化"></a>计算优化</h4><h4 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h4><h4 id="实验设定与结果"><a href="#实验设定与结果" class="headerlink" title="实验设定与结果"></a>实验设定与结果</h4><h4 id="内存占用、优化技巧与加速比"><a href="#内存占用、优化技巧与加速比" class="headerlink" title="内存占用、优化技巧与加速比"></a>内存占用、优化技巧与加速比</h4><p>$F(I_{2\cdot 2},K_{3 \cdot 3})$的加速比上限是2.25，$F(I_{4\cdot 4},K_{3 \cdot 3})$的加速比上限是4。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="矩阵参数获取"><a href="#矩阵参数获取" class="headerlink" title="矩阵参数获取"></a>矩阵参数获取</h4><h4 id="端侧推理"><a href="#端侧推理" class="headerlink" title="端侧推理"></a>端侧推理</h4><p>以$F(I_{2\cdot 2},K_{3 \cdot 3})$为例，我们来看看代码是如何实现的，代码来自Tencent NCNN。</p><ol><li>Filter Transform</li><li>Input transform</li><li>Hadamard product</li><li>Output transform</li></ol><p>$F(I_{4\cdot 4},K_{3 \cdot 3})$的实现就更加复杂，可以看参考资料中Tencent NCNN的实现。</p><h2 id="跑题：-NHWC、HCHW和NC-4HW4"><a href="#跑题：-NHWC、HCHW和NC-4HW4" class="headerlink" title="跑题： NHWC、HCHW和NC/4HW4"></a>跑题： NHWC、HCHW和NC/4HW4</h2><p>我们在说NHWC时，实际上是说数据在内存上的排布策略，以及探讨该策略带来的访存性能变化。</p><p>NHWC与HCHW的区别用一张图就可以说清楚，其中我们的N=1，C=3，H=1，W=6：</p><p><img src="fig_nchw.webp" alt></p><blockquote><p><strong>NHWC 的访存局部性更好</strong>（每三个输入像素即可得到一个输出像素），<strong>NCHW</strong> 则必须等所有通道输入准备好才能得到最终输出结果，<strong>需要占用较大的临时空间</strong>。</p><p>在 CNN 中常常见到 1x1 卷积（例如：<a href="http://mp.weixin.qq.com/s?__biz=MzI2MzYwNzUyNg==&mid=2247483973&idx=1&sn=b0b9aa4190f5ac9a34421beaa92eb932&chksm=eab807ccddcf8edaa798098c73b82ee35f4b22e159ddcd4ffb0d0cd6cae77a170a59a5c441e4&scene=21#wechat_redirect" target="_blank" rel="noopener">用于移动和嵌入式视觉应用的 MobileNets</a>），也是每个输入 channel 乘一个权值，然后将所有 channel 结果累加得到一个输出 channel。如果使用 NHWC 数据格式，可以将卷积计算简化为矩阵乘计算，即 <strong>1x1 卷积核实现了每个输入像素组到每个输出像素组的线性变换</strong>。</p><p>TensorFlow 为什么选择 NHWC 格式作为默认格式？因为早期开发都是基于 CPU，使用 NHWC 比 NCHW 稍快一些（不难理解，NHWC 局部性更好，cache 利用率高）。</p><p>NCHW 则是 Nvidia cuDNN 默认格式，使用 GPU 加速时用 NCHW 格式速度会更快（也有个别情况例外）。</p></blockquote><p>最早接触到NC/4HW4是因为阿里的端侧推理框架MNN，不得不说这个框架真是太复杂了，随便拿一个技术点就能扯上半天。</p><p>NC/4HW4第一个4表示把原Feature map的通道按4分组不够补0，然后每组内的4个Feature map按照RGBA交织排列。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Winograd算法存在一定的计算精度损失。不过CNN模型需要的计算精度实际上很低，例如有用fp16、int8实现CNN的方法，也有用更低bit数甚至binary计算实现的方法，它们都有不错的ImageNet分类精度。 </li><li><code>tile</code>越大，加速比越大，卷积核大小也类似，但所需的加法、transform和存储的代价，计算精度的损失都会迅速增大。 因此通常只会采用较小的<code>tile</code>和卷积核大小，最常见的实现为$F(I_{2\cdot 2},K_{3 \cdot 3})$，$F(I_{4\cdot 4},K_{3 \cdot 3})$，$F(I_{6\cdot 6},K_{3 \cdot 3})$。</li><li>Winograd算法可以用矩阵形式来表示，但是具体实现时，并不意味着要调用矩阵运算的接口，为了更快的计算速度，通常会直接将计算展开，故代码量较大，且对于不同的<code>tile</code>大小需要专门定制的代码（好在也就那么几种），通常卷积核的大小为$2\times 2$到$7\times 7$。在划分方式上，$F(I_{1\cdot 1},K_{r \cdot r})$和im2col没有本质区别。</li><li></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/shine-lee/p/10906535.html" target="_blank" rel="noopener">卷积神经网络中的Winograd快速卷积算法</a></li><li><a href="https://hey-yahei.cn/2019/08/21/winograd_convolution/" target="_blank" rel="noopener">Winograd卷积原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/82482351" target="_blank" rel="noopener">源于《孙子算经》的Cudnn</a></li><li><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Lavin_Fast_Algorithms_for_CVPR_2016_paper.pdf" target="_blank" rel="noopener">Paper-CVPR 2016-Fast Algorithms for Convolutional Neural Networks</a></li><li><a href="https://books.google.com/books?id=wANiW8bGQpEC" target="_blank" rel="noopener">Book-Shmuel Winograd.1980 Arithmetic complexity of computations</a></li><li><a href="https://yq.aliyun.com/articles/707074" target="_blank" rel="noopener">开源背后 | 面对端侧推理引擎的挑战，阿里工程师如何应对</a></li><li><a href="https://github.com/Tencent/FeatherCNN/blob/booster/src/booster/arm/winograd_kernels.cpp" target="_blank" rel="noopener">Tencent FeatherCNN实现</a></li><li><a href="https://github.com/Tencent/ncnn/blob/master/src/layer/x86/convolution_3x3.h" target="_blank" rel="noopener">Tencent NCNN 3x3实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/51569443" target="_blank" rel="noopener">深度学习轻量级推理及加速</a></li><li><a href="https://zhuanlan.zhihu.com/p/67117914" target="_blank" rel="noopener">【移动端DL框架】当前主流的移动端深度学习框架一览</a></li><li><a href="https://www.bilibili.com/video/av50718398" target="_blank" rel="noopener">Video-Fast Algorithms for Convolutional Neural Networks by Andrew Lavin and Scott Gray</a></li><li><a href="https://www.bilibili.com/video/av53072685" target="_blank" rel="noopener">Video-Even Faster CNNs Exploring the New Class of Winograd Algorithms</a></li><li><a href="https://www.slideshare.net/embeddedvision/even-faster-cnns-exploring-the-new-class-of-winograd-algorithms-a-presentation-from-arm?from_action=save" target="_blank" rel="noopener">PPT-算法解析</a></li><li><a href="https://arxiv.org/abs/1810.01973" target="_blank" rel="noopener">Paper-Sparse Winograd Convolutional neural networks on small-scale systolic arrays</a> </li><li><a href="https://github.com/andravin/wincnn" target="_blank" rel="noopener">Code-参数生成 andravin/wincnn</a></li><li><a href="http://people.ece.umn.edu/users/parhi/SLIDES/chap8.pdf" target="_blank" rel="noopener">PPT-Fast Convolution</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卷积神经网络 </tag>
            
            <tag> Winograd </tag>
            
            <tag> 端侧推理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[动态规划]LeetCode-72.编辑距离</title>
      <link href="/2019/11/09/dong-tai-gui-hua-leetcode-72-bian-ji-ju-chi/"/>
      <url>/2019/11/09/dong-tai-gui-hua-leetcode-72-bian-ji-ju-chi/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li><p>插入一个字符</p></li><li><p>删除一个字符</p></li><li><p>替换一个字符</p></li></ol><p>示例 1:</p><pre><code>输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)</code></pre><p>示例 2:</p><pre><code>输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;)</code></pre><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>编辑距离（Minimum Edit Distance，MED）是用来衡量两个字符串相似度的常用方法， 求两个字符串的编辑距离也算是一个经典问题了。</p><p>我们的两个字符串$A$,$B$分别代表了当前的字符串和目标字符串，实际上，将$A$变成$B$和将$B$变成$A$所需要的步数是一样的（逆过程），因此所需要的最小步数才可以用距离这个概念来表示。</p><p>如果有一个字符串是空串，那么显然可以只用另一个字符串的长度来表示，即：<br>$$<br>Dis(A,B)=max(len(A),len(B)),  if(len(A)==0 || len(B)==0)<br>$$<br>此外，距离可以从上一步的最优结果推到而来，这就是编辑距离的动态规划解法，注意到我们的三种情况其实就对应了三种允许的操作。看起来删除和插入操作好像是对称的，其实并没有本质的区别，只是因为我们的目标字符串是$B$：</p><p>$$<br>Dis(A_i,B_j)=min(Dis(A_{i-1},B_j)+1,Dis(A_i,B_{j-1})+1,Dis(A_{i-1},B_{j-1})+(A_i==B_j))<br>$$</p><p>三个操作分别表示</p><ul><li><p>删除字符$A_i$，因为$Dis(A_{i-1},B_j)$已经满足成为字符串$B_{1:j}$的条件</p></li><li><p>插入字符$B_j$</p></li><li><p>相等不操作，不相等则将字符$A_i$替换为$B_j$</p></li></ul><p>实际上在最后一个字母相等的情况下，肯定是直接等于左上角的结果最小，不需要再额外判断了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>String word1<span class="token punctuation">,</span> String word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len1<span class="token operator">=</span>word1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>len2<span class="token operator">=</span>word2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> word2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span>len2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>dis<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> dis<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>j<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span>word2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dis<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token keyword">return</span> dis<span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>优化空间：</strong>这里我们使用的只有两行结果，因此可以使用滚动数组进行优化，不过对这道题目的数据而言意义不大hhh：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>String word1<span class="token punctuation">,</span> String word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len1<span class="token operator">=</span>word1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>len2<span class="token operator">=</span>word2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> word2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span>len2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*        if(len1>len2){            String tmp=word2;            word2=word1;            word1=tmp;            len1=word1.length();            len2=word2.length();        }         */</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>dis<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> dis<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>j<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> curIndex<span class="token operator">=</span>i<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">,</span>lastIndex<span class="token operator">=</span><span class="token number">1</span><span class="token operator">-</span>curIndex<span class="token punctuation">;</span>            dis<span class="token punctuation">[</span>curIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>len2<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span>word2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    dis<span class="token punctuation">[</span>curIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dis<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dis<span class="token punctuation">[</span>curIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>dis<span class="token punctuation">[</span>curIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dis<span class="token punctuation">[</span>len1 <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 经典算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数学]LeetCode-31.下一个排列</title>
      <link href="/2019/11/08/shu-xue-leetcode-31-xia-yi-ge-pai-lie/"/>
      <url>/2019/11/08/shu-xue-leetcode-31-xia-yi-ge-pai-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，<strong>只允许使用额外常数空间</strong>。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be in-place and use only constant extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p><p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/next-permutation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-permutation</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><p>题目的意思是找一个字典序刚好比当前序列大的排列，如果当前序列已经是降序的，那么直接倒转即可</p></li><li><p>原地算法表示程序使用的空间必须是常数，与输入的数据规模无关</p></li><li><p>在中间的某一个排列可以分为三段，A:从前往后递增，B:从后往前递增，C:A与B之间的数（可能不存在），如数列</p><p>[<strong>1,2,7</strong>,4,5,<strong><em>6,3</em></strong>],要找到字典序更大的，无论如何调整B都不可能，而B中势必存在比C中最后一个元素更大的数，那么我们只需要将这个数换成B中刚好比他大的，再做一些调整就可以了。当然C可能不存在，那么实际上C就是A的最后一个元素。</p><p>我们需要找到的是满足条件的排列中，字典序最小的，因此在做完交换后，所需要做的调整就是将最后一段（长度和B相等）变成字典序最小的情况，显然这一段依然是单调递减的（从后往前递增），因此只要将这一段倒转即可。</p><p>[<strong>1,2,7</strong>,4,5,<strong><em>6,3</em></strong>]–&gt;[<strong>1,2,7</strong>,4,6,<strong><em>5,3</em></strong>]–&gt;[<strong>1,2,7</strong>,4,6,<strong><em>3,5</em></strong>]</p></li><li><p>想法的表述可能比较啰嗦，具体而言，算法分为4步：</p><ul><li>从后往前找到第一个不再增加的数字$S_i$</li><li>找到这个数字后刚好比他大的数字$S_j$</li><li>交换$S_i$与$S_j$</li><li>将$S_j$之后的一段数（这里是说下标$i$对应的那个位置，现在右侧可能就只有$S_i$）倒转</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//一些特例</span><span class="token comment" spellcheck="true">//{1},{2,1}</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">nextPermutation</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>n<span class="token number">-2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//对应于两个特例，需要判断i是否越界</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>n<span class="token number">-1</span><span class="token punctuation">;</span>j<span class="token operator">></span>i<span class="token punctuation">;</span><span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[单调栈]LeetCode-739.每日温度</title>
      <link href="/2019/11/07/dan-diao-zhan-leetcode-739-mei-ri-wen-du/"/>
      <url>/2019/11/07/dan-diao-zhan-leetcode-739-mei-ri-wen-du/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.</p><p>For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].</p><p>Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].</p><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>题意即找到每个数右侧第一个大于该数的数字，除了暴力遍历以外，另一种做法是保留我们遇到的数字，直到找到答案了再移除，可以借助单调栈的结构，此处使用单调<strong>非</strong>递增栈，方便起见只保存下标。</p><ul><li>单调<strong>非</strong>递增栈（&lt;=）：从栈底到栈顶的数字越来越小，允许重复</li><li>单调递减栈(&lt;)：从栈底到栈顶的数字越来越小，<strong>不</strong>允许重复</li></ul><p>本题既可以顺序遍历也可以逆序遍历</p><ul><li>顺序遍历方案：保留遇到的数字，如果当前数字比栈顶元素（之前遇到的）大，那么当前数字就是之前那个数字的答案</li><li>逆序遍历方案：从右往左遍历，去除栈顶所有比当前元素小的元素，如果栈空，那说明没有比当前元素大的，否则栈顶元素就是当前元素的答案</li></ul><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//单调栈从右往左遍历</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>ret<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>T<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>T<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> cur<span class="token operator">=</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> T<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>cur<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//单调栈从左往右遍历</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len<span class="token operator">=</span>T<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>ret<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> cur<span class="token operator">=</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> T<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> tp<span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ret<span class="token punctuation">[</span>tp<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">-</span>tp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>另一种思路不是该题的标准解，但是想法很巧妙，速度又很快。</p><p>具体而言，由于我们得到的结果实际上就代表了比当前元素大的所在位置，因此可以直接进行跳转，不需要再一个个比较，有点类似于KMP中的跳转表。</p><p><img src="fig_method2.png" alt></p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//利用ret[j]的结果进行跳转</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>ret<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>T<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>T<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从下一个元素开始，每次都试图调到比当前元素更大的元素</span>            <span class="token comment" spellcheck="true">//小的那些就不再比较了</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>T<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">+=</span>ret<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>j<span class="token operator">-</span>i<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新坑落成纪念</title>
      <link href="/2019/11/06/xin-keng-luo-cheng-ji-nian/"/>
      <url>/2019/11/06/xin-keng-luo-cheng-ji-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="20191106"><a href="#20191106" class="headerlink" title="20191106"></a>20191106</h2><p>很久没有写博客啦，之前学习的东西都没有系统的整理过，因此和小伙伴@Fx-Ren(<a href="mailto:awesome_rfx@163.com" target="_blank" rel="noopener">awesome_rfx@163.com</a>)一起开一个新坑，给自己一些压力，希望之后能更新的勤快一些。</p><p>博客配置参考了<a href="https://godweiyang.com/2018/04/13/hexo-blog" target="_blank" rel="noopener">这个</a>,主题是<strong><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">Matery</a></strong>，感谢原作者。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
